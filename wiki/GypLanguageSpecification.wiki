#labels Featured
GYP (Generate Your Projects)
<BR>Status: Draft (as of 2009-01-30)

Mark Mentovai <mark@chromium.org> _et al._
<BR>Modified: 2009-01-30

Contents

<wiki:toc max_depth="2" />

= Objective =

Create a tool for the Chromium project that generates native Visual Studio, Xcode and SCons and/or make build files from a platform-independent input format.  Make the input format as reasonably general as possible without spending extra time trying to "get everything right," except where not doing so would likely lead Chromium to an eventual dead end.  When in doubt, do what Chromium needs and don't worry about generalizing the solution.

= Background =

Numerous other projects, both inside and outside Google, have tried to create a simple, universal cross-platform build representation that still allows sufficient per-platform flexibility to accommodate irreconcilable differences.  The fact that no obvious working candidate exists that meets Chromium's requirements indicates this is probably a tougher problem than it appears at first glance.  We aim to succeed by creating a tool that is highly specific to Chromium's specific use case, not to the general case of design a completely platform-independent tool for expressing any possible build.

The Mac has the most sophisticated model for application development through an IDE.  Consequently, we will use the Xcode model as the starting point (the input file format must handle Chromium's use of Xcode seamlessly) and adapt the design as necessary for the other platforms.

= Overview =

The overall design has the following characteristics:

  * Input configurations are specified in files with the suffix `.gyp`.
  * Each `.gyp` file specifies how to build the targets for the "component" defined by that file.
  * Each `.gyp` file generates one or more output files appropriate to the platform:
    * On Mac, a `.gyp` file generates one Xcode .xcodeproj bundle with information about how its targets are built.
    * On Windows, a `.gyp` file generates one Visual Studio .sln file, and one Visual Studio .vcproj file per target.
    * On Linux, a `.gyp` file generates one SCons file and/or one Makefile per target
  * The `.gyp` file syntax is a Python data structure.
  * Use of arbitrary Python in `.gyp` files is forbidden.
    * Use of eval() on `.gyp` file contents restricts the input to an evaluated expression, not arbitrary Python statements.
  * Input data is a dictionary of keywords+values.
  * "Invalid" keywords on any given data structure are not illegal, they're just ignored.
    * TODO:  providing warnings on use of illegal keywords would help users catch typos.  Figure out something nice to do with this.

= Detailed Design =

Some up-front design principles/thoughts/TODOs:

  * Re-use keywords consistently.
  * Keywords that allow configuration of a platform-specific concept get prefixed appropriately:
    * Examples:  `vs_post_tools`, `xcode_framework_dirs`
  * The input syntax is declarative and data-driven.
    * This gets enforced by using Python `eval()` (which only evaluates an expression) instead of `exec` (which executes arbitrary python)
  * Semantic meanings of specific keyword values get deferred until all are read and the configuration is being evaluated to spit out the appropriate file(s)
  * Source file lists:
    * Are unordered, flat lists.  Any imposed ordering within the `.gyp` file (e.g. alphabetically) is purely by convention and for developer convenience.
    * Source file lists contain no mechanism for by-hand folder configuration (`Filter` tags in Visual Studio, `Groups` in Xcode)
    * A folder hierarchy is created automatically that mirrors the file system

== Example ==

{{{
{
  'settings': {
    'defines': [
      'U_STATIC_IMPLEMENTATION',
      ["LOGFILE", 'foo.log',],
    ],
    'include_dirs': [
      '..',
    ],
  },
  'targets': [
    {
      'name': 'foo',
      'type': 'static_library',
      'sources': [
        'foo/src/foo.cc',
        'foo/src/foo_main.cc',
      ],
      'include_dirs': [
         'foo',
         'foo/include',
      ],
      'conditions': [
         [ 'OS==mac', { 'sources': [ 'platform_test_mac.mm' ] } ]
      ],
      'dependent_settings': {
        'defines': [
          'UNIT_TEST',
        ],
        'include_dirs': [
          'foo',
          'foo/include',
        ],
      },
    },
  ],
}
}}}

== Structural Elements ==

== Top-level Dictionary ==

This is the single dictionary in the `.gyp` file that defines the targets and how they're to be built.

The following keywords are meaningful within the top-level dictionary definition:

|| `settings` || A dictionary of default settings to be inherited by all targets in the top-level dictionary.  See the "Settings keywords" section below. ||
|| `targets` || A list of target specifications.  See the "targets" below. ||

== targets ==

A list of dictionaries defining targets to be built by the files generated from this `.gyp` file.

The following keywords have structural meaning for target definitions:

|| `conditions` || A list of condition specifications to be applied to the settings for this target. See the "Keyword: conditions" section below. ||
|| `dependent_settings` || A dictionary of settings to be applied to other targets that depend on this target. ||

The other keywords in a dictionary in the `targets` list are settings to be applied when building that target.  See the "Settings keywords" section below.

== conditions ==

A list of keyword+value pairs. The keyword is a string containing an expression to be evaluated. The value is a dictionary containing settings to be applied to the target's if the expression evaluates true.

The `eval()` of the expression string takes place in the context of global and/or local dictionaries that we construct from the `.gyp` input data, and overrides the `__builtin__` dictionary, to prevent the execution of arbitrary Python code.

TODO(sgk+mark):  document condition evaluation order

== Settings keywords ==

These are keywords whose values make up the bulk of the actual data written into the generated files.  Settings keywords can meaninfully show up in the following places:

  * The `settings` section of the top-level dictionary
  * A dictionary defining an individual target (in the `targets` list of the top-level dictionary)
  * The `dependent_settings` dictionary within a dictionary defining a target.
  * A dictionary associated with a conditional expression in the `conditions` section of a target

The following keywords are meaningful within a settings section:

|| `defines` || A list of preprocesor definitions to be passed on the command line to the C/C++ compiler (via `-D` or `/D` options). ||
|| `dependencies` || A list of targets on which this target depends. Targets in other `.gyp` files are specified as `../path/to/other.gyp:target_we_want`. ||
|| `include_dirs` || A list of include directories to be passed on the command line to the C/C++ compiler (via `-I` or `/I` options). ||
|| `libraries` || A list of list of libraries (and/or frameworks) on which this target depends. ||
|| `name` || The name of a target being defined. ||
|| `sources` || A list of source files that are used to build this target or which should otherwise show up in the IDE for this target.  In practice, we expect this list to be a union of all files necessary to build the target on all platforms, as well as other related files that aren't actually used for building, like README files. ||
|| `type` || The type of target being defined. The list of acceptable `type` values is below.||
|| `vs_props` || A list of Visual Studio property sheets (`.vsprops` files) to be used to build the targets. ||
|| `xcode_configs` || A list of Xcode configurations (`.xcconfig` files) to be used to build the targets. ||
|| `xcode_framework_dirs` || A list of framework directories be used to build the targets. ||

Valid `type` values are (TODO(sgk):  validate this stake-in-the-ground list with everyone):

  * `static_library`
  * `shared_library`
  * `executable`

TODO(sgk+mark):  document settings merging with new `+ - ! /` characters


== Generated Xcode .pbxproj Files ==

We derive the following things in a `project.pbxproj` plist file within the `.xcodeproj` bundle from the above input file formats as follows:

  * `Group hierarchy`: This is generated in a fixed format with contents derived from the input files. There is no provision for the user to specify additional groups or create a custom hierarchy. (TODO(all): RIGHT? Mark notes: Almost certainly, my generator allows for the flexibility but I wasn't planning on doing anything special in the glue.)
    * `Configuration group`:
    * `Source group`: The union of the `sources` lists of all `targets` after applying appropriate `conditions`.  The resulting list is sorted and put into a group hierarchy that matches the layout of the directory tree on disk, with a root of // (the top of the hierarchy).
    * `Frameworks group`: Taken directly from `libraries` value for the target, after applying appropriate conditions.
    * `Projects group`: References to other `.xcodeproj` bundles that are needed by the `.xcodeproj` in which the group is contained.
    * `Products group`: Output from the various targets.
  * `Project References`:
  * `Project Configurations`:
  * `Targets`:
    * `Phases`: Copy sources, link with libraries/frameworks, ...
    * `Target Configurations`: Specified by input.  TODO(mark): Implement.
    * `File Configurations`: Per-build file settings are not supported.
    * `Dependencies`: (local and remote)

== Generated Visual Studio .vcproj Files ==

We derive the following sections in a `.vcproj` file from the above input file formats as follows:

  * `VisualStudioProject`:
    * `Platforms`:
    * `ToolFiles`:
    * `Configurations`:
      * `Configuration`:
    * `References`:
    * `Files`:
      * `Filter`:
      * `File`:
        * `FileConfiguration`:
          * `Tool`:
    * `Globals`:

== Generated Visual Studio .sln Files ==

We derive the following sections in a `.sln` file from the above input file formats as follows:

  * `Projects`:
    * `WebsiteProperties`:
    * `ProjectDependencies`:
  * `Global`:
    * `SolutionConfigurationPlatforms`:
    * `ProjectConfigurationPlatforms`:
    * `SolutionProperties`:
    * `NestedProjects`:

= Code Location =

Here!  http://gyp.googlecode.com/

= Group Members =

|| Darin Fisher || Overall approval of final design ||
|| Elliot Glaysher || Approval of Linux build functionality. ||
|| Alex Harper || ||
|| Steven Knight || Language specification. ||
|| Mark Mentovai || Input language design and implementation.<br/>Code for generating Xcode files from `.gyp` files.<br/>Approval of Mac (Xcode) build functionality. ||
|| Bradley Nelson || Code for generating Visual Studio files from `.gyp` files. ||
|| Randall Spangler || ||
|| Nicolas Sylvain || Approval of Windows build functionality. ||

= Caveats =

TODO(sgk):  Notes/Question from very first prototype draft of the language.  Make sure these issues are addressed somewhere before deleting.

  * Libraries are easy, application abstraction is harder
    * Applications involves resource compilation
    * Applications involve many inputs
    * Applications include transitive closure of dependencies
  * Specific use cases like cc_library
    * Mac compiles more than just .c/.cpp files (specifically, .m and .mm files)
    * Compiler options vary by:
      * File type
      * Target type
      * Individual file
    * Files may have custom settings per file per platform
  * Will all linked non-Chromium projects always use the same versions of every subsystem?
  * Variants are difficult.  We've identified the following variants (some specific to Chromium, some typical of other projects in the same ballpark):
    * Target platform
    * V8 vs. JSC
    * Debug vs. Release
    * Toolchain (VS version, gcc, version)
    * Host platform
    * L10N
    * Vendor
    * Purify / Valgrind
  * Will everyone upgrade VS at once?
  * What does a dylib dependency mean?

= Testing Plan =

_What are the sub-units of your system that will be independently testable? Tests must be approved by the code reviewer, and must follow the guidelines in the unittesting document as far as possible. See What Is A Design Document for criteria for whole system tests on servers.
If there are changes envisaged in your future work, would your tests verify the base functionality? If some of your tests cannot be easily automated (e.g. UI tests), how will you document the needed special procedures?_

= Documentation Plan =

Documentation via this wiki: http://code.google.com/p/gyp

= Work Estimates =

_Estimates of how long each phase will take (please be detailed; subtask granularity should be roughly one week)_

= Launch Plans =

_What are the launch plans for your project? This includes, but is not limited to:
What visible changes your project will cause on the site.
What will be the impact on production and/or search partners.
What new servers will be introduced.
Rough timeline for releasing your project._
